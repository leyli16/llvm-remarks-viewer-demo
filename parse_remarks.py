"""
Demo: LLVM Remarks YAML Parser

This is a demo script that parses LLVM optimization remarks 
from a `.opt.yaml` file (generated by Clang), filters selected 
fields, and outputs a cleaned JSON file (`remarks.json`) for visualization.

Intended for research, prototyping, and visualization tool development.
Author: Le Li (https://github.com/leyli16)
"""

import yaml
from yaml.constructor import SafeConstructor
import json
from dataclasses import dataclass, asdict
from typing import Dict, List, Optional

# Add custom YAML constructor for !Analysis tag
class AnalysisConstructor(SafeConstructor):
    def construct_analysis(self, node):
        return self.construct_mapping(node)

AnalysisConstructor.add_constructor('!Analysis', AnalysisConstructor.construct_analysis)

class AnalysisLoader(AnalysisConstructor, yaml.Loader):
    pass

@dataclass
class Remark:
    pass_name: str
    name: str
    function: str
    message: str
    file: Optional[str] = None
    line: Optional[int] = None

class RemarksParser:
    def __init__(self):
        self.remarks: List[Remark] = []

    def parse_file(self, filename: str):
        """Parse the YAML remarks file."""
        with open(filename, 'r') as file:
            # Use custom loader instead of safe_load_all
            documents = list(yaml.load_all(file, Loader=AnalysisLoader))

        for doc in documents:
            if doc.get('Pass') and doc.get('Function'):
                self._process_remark(doc)

    def _process_remark(self, doc: dict):
        """Process a single remark document."""
        # Extract debug location information
        debug_loc = doc.get('DebugLoc', {})
        file = debug_loc.get('File')
        line = debug_loc.get('Line')

        # Construct the message based on the remark type
        message = self._construct_message(doc)

        # Create a new remark
        remark = Remark(
            pass_name=doc['Pass'],
            name=doc['Name'],
            function=doc['Function'],
            message=message,
            file=file,
            line=line
        )
        
        self.remarks.append(remark)

    def _construct_message(self, doc: dict) -> str:
        """Construct a human-readable message from the remark data."""
        if doc['Name'] == 'StackSize':
            stack_bytes = doc['Args'][0]['NumStackBytes']
            function_name = doc['Args'][2]['Function']
            return f"Function '{function_name}' uses {stack_bytes} stack bytes"
        
        elif doc['Name'] == 'InstructionCount':
            num_instructions = doc['Args'][0]['NumInstructions']
            return f"Function contains {num_instructions} instructions"
        
        elif doc['Name'] == 'InstructionMix':
            inst_count = doc['Args'][5]['INST_']
            return f"Basic block contains {inst_count} instructions"
        
        return "Unknown remark type"

    def to_json(self, output_file: str):
        """Convert the parsed remarks to JSON and save to a file."""
        output_data = {
            "remarks": [
                {
                    "Pass": remark.pass_name,
                    "Name": remark.name,
                    "Function": remark.function,
                    "Message": remark.message,
                    "File": remark.file,
                    "Line": remark.line
                }
                for remark in self.remarks
            ]
        }
        
        with open(output_file, 'w') as f:
            json.dump(output_data, f, indent=2)

def main():
    try:
        parser = RemarksParser()
        parser.parse_file('example.opt.yaml')
        parser.to_json('remarks.json')
        print("Successfully parsed remarks and saved to remarks.json")
    except FileNotFoundError:
        print("Error: Could not find example.opt.yaml")
    except Exception as e:
        print(f"Error occurred: {str(e)}")

if __name__ == "__main__":
    main() 